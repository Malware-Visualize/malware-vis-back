import time
import zipfile
import numpy as np
from scipy.cluster.hierarchy import ward, dendrogram, single
import matplotlib.pyplot as plt
import math

# 입력으로 받은 압축 파일을 사용할 수 있도록 전처리
def unzipfile(file):
    start_pre = time.time()
    api_list = []
    api_data = []
    with zipfile.ZipFile(file, 'r') as obj:
        zip_namelist = obj.namelist()
        for name in zip_namelist:
            line = obj.read(name).decode('ASCII')
            line = line.replace("\n", "")
            line = line.replace("\'", "")
            my_list = line.split(",")
            my_list.pop(0)
            api_list.append(my_list)
            api_data.append({name: my_list})
    end_pre = time.time()
    return api_data, api_list, (end_pre - start_pre)


# API 리스트의 유사성을 계산하여 거리 행렬 생성
def calculate_distance(api_list1, api_list2):
    intersection_count = 0
    for api in set(api_list1):  # 교집합의 크기 파악, 한 리스트의 api를 서로가 가진 수를 확인하고 최솟값을 취함
        count1 = api_list1.count(api)
        count2 = api_list2.count(api)
        intersection_count += min(count1, count2)
    union_count = len(api_list1) + len(api_list2) - intersection_count  # 합집합의 크기 파악
    return 1 - intersection_count / union_count  # 유사도를 거리로 변환, 유사도가 크면 가깝다는 뜻으로 1에서 빼 원하는 결과로 변경


def cal_similarity(malware_api_lists):
    start_cal = time.time()
    num_samples = len(malware_api_lists)
    distance_matrix = np.zeros((num_samples, num_samples))  # 각 악성코드 간의 API 유사도 거리를 행렬에 저장
    for i in range(num_samples):
        for j in range(i, num_samples):
            distance_matrix[i, j] = calculate_distance(malware_api_lists[i], malware_api_lists[j])
            distance_matrix[j, i] = distance_matrix[i, j]

    end_cal = time.time()
    return distance_matrix, (end_cal-start_cal)


def ward_dist(distance_matrix):
    start_ward = time.time()
    # Ward 거리로 변환하여 계층적 클러스터링 수행, [요소1, 요소2, 둘의 와드거리, 합쳐진 후 군집의 크기]
    Z_ward = ward(distance_matrix)
    max_d = 2  # 클러스터 결정을 위한 최대 거리

    # 덴드로그램 시각화
    label = np.arange(len(distance_matrix))

    for i in range(len(label)):
        label[i] = label[i] + 1

    plt.figure(figsize=(12, 6))
    dendrogram(Z_ward, labels=label, color_threshold=max_d)

    end_ward = time.time()
    log_Z_ward = Z_ward[:]
    for i in range(len(Z_ward)):
        log_Z_ward[i][2] = math.log10(1 + Z_ward[i][2])

    # 리스트의 인덱스 = 합쳐지는 순서, 내부 딕셔너리 요소 > 와드거리 값 : 해당하는 api 번호 리스트
    # 결과를 저장할 리스트
    result = []

    # 초기 클러스터를 추적하는 딕셔너리
    cluster_map = {i: [i] for i in range(len(distance_matrix))}

    # 새로운 클러스터의 인덱스를 추적
    next_cluster_index = len(distance_matrix)

    # 주어진 거리 행렬을 처리하여 결과 리스트를 생성
    for row in Z_ward:
        cluster1, cluster2, distance, num_elements = int(row[0]), int(row[1]), row[2], int(row[3])

        # 클러스터 병합
        new_cluster = list(set(cluster_map[cluster1] + cluster_map[cluster2]))

        # 거리 값이 같은 경우 병합
        if result and distance in result[-1]:
            result[-1][distance] = list(set(result[-1][distance] + new_cluster))
        else:
            result.append({distance: new_cluster})

        # 새로운 클러스터 업데이트
        cluster_map[next_cluster_index] = new_cluster
        next_cluster_index += 1

        # 병합된 클러스터 삭제
        del cluster_map[cluster1]
        del cluster_map[cluster2]

    plt.xlabel('Malware Samples')
    plt.ylabel('Distance')
    plt.title('Hierarchical Clustering of Malware Samples based on API Calls using Ward Distance')
    plt.savefig("static/ward.png")

    plt.figure(figsize=(12, 6))
    dendrogram(log_Z_ward, labels=label, color_threshold=max_d)

    plt.xlabel('Malware Samples')
    plt.ylabel('Distance')
    plt.title('Hierarchical Clustering of Malware Samples based on API Calls using log Ward Distance')
    plt.savefig("static/log_ward.png")
    return result, end_ward-start_ward


def single_dist(distance_matrix):
    start_single = time.time()
    single_dis = single(distance_matrix)

    max_d = 1  # 클러스터 결정을 위한 최대 거리

    # 덴드로그램 시각화
    label = np.arange(len(distance_matrix))
    for i in range(len(label)):
        label[i] = label[i] + 1

    plt.figure(figsize=(12, 6))
    dendrogram(single_dis, labels=label, color_threshold=max_d)

    end_single = time.time()

    plt.xlabel('Malware Samples')
    plt.ylabel('Distance')
    plt.title('Hierarchical Clustering of Malware Samples based on API Calls using Single Distance')
    plt.savefig("static/single.png")
    return end_single-start_single
